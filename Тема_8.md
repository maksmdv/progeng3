# Тема_8: Введение в ООП

- Студент: Шулешов Максим Андреевич
- Группа: ИВТ-23-2

#Лабораторная работа по Python
## №1
Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.

```
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

my_car = Car("Totota", "Corolla")
```

### Вывод:
Создан базовый класс Car с конструктором, который принимает параметры производителя (make) и модели (model). При создании объекта my_car эти параметры сохраняются в атрибутах объекта. Это демонстрирует принцип инкапсуляции данных в классе.

## №2
Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")


my_car = Car("Totota", "Corolla")
my_car.drive()
```

### Результат
![Меню](/img7/t1.png)

### Вывод:
Класс Car дополнен методом drive(), который выводит сообщение о движении автомобиля. При вызове метода drive() для объекта my_car в консоль выводится "Driving the Toyota Corolla". Это показывает работу методов класса и взаимодействие с атрибутами объекта.

## №3
Напишите программу, которая выведет все строки из вашего файла в массиве, при этом используйте констСоздайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```
fclass Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity

    def charge(self):
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")

my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
```

### Результат
![Меню](/img7/t2.png)

### Вывод:
Реализовано наследование - класс ElectricCar наследует от класса Car. Добавлен новый атрибут battery_capacity и метод charge(). Объект my_electric_car может использовать как унаследованный метод drive(), так и собственный метод charge(). Это демонстрирует принцип наследования в ООП.

## №4
Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```
class Car:
    def __init__(self, make, model):
        self._make = make
        self.__model = model

    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

my_car = Car("Totota", "Corolla")
print(my_car._make)
my_car.drive()
```

### Результат
![Меню](/img7/t3.png)

### Вывод:
Реализована инкапсуляция: атрибут _make защищенный (доступен, но не рекомендуется для прямого использования), а __model - приватный (недоступен напрямую извне класса). При вызове print(my_car._make) получаем доступ к защищенному атрибуту, а метод drive() работает корректно, используя приватный атрибут.

## №5
Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

rect = Rectangle(4, 5)
print(rect.area())

circle = Circle(3)
print(circle.area())
```

### Результат
![Меню](/img7/t4.png)

### Вывод:
Реализован полиморфизм через переопределение метода area() в классах-наследниках Rectangle и Circle. Каждый класс вычисляет площадь по своей формуле, но интерфейс метода одинаков. Это позволяет работать с разными типами фигур единообразно.

#Самостоятельная работа по Python

## №6
Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def display(self):
        print(f"Book: '{self.title}' by {self.author}")

my_book = Book("1984", "George Orwell")
my_book.display()

```

### Результат
![Меню](/img7/t5.png)

### Вывод:
Создан собственный класс Book с атрибутами title и author. Метод display() выводит информацию о книге. Объект my_book успешно создается и выводит информацию "Book: '1984' by George Orwell".

## №7
Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def display(self):
        print(f"Book: '{self.title}' by {self.author}, {self.pages} pages")

    def is_long(self):
        return self.pages > 300

my_book = Book("1984", "George Orwell", 328)
my_book.display()
print("Is long book:", my_book.is_long())

```

### Результат
![Меню](/img7/t6.png)

### Вывод:
Класс Book расширен атрибутом pages и методом is_long(), который проверяет, является ли книга длинной. Демонстрирует добавление функциональности к существующему классу и работу с дополнительными атрибутами.

## №8
Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def display(self):
        print(f"Book: '{self.title}' by {self.author}, {self.pages} pages")

class EBook(Book):
    def __init__(self, title, author, pages, filesize):
        super().__init__(title, author, pages)
        self.filesize = filesize

    def display(self):
        super().display()
        print(f"File size: {self.filesize} MB")

my_ebook = EBook("1984", "George Orwell", 328, 2)
my_ebook.display()

```

### Результат
![Меню](/img7/t7.png)

### Вывод:
Реализовано наследование - класс EBook наследует от Book и добавляет атрибут filesize. Метод display() переопределен для вывода дополнительной информации. Показывает расширение функциональности родительского класса через наследование.

## №9
Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def display(self):
        print(f"Book: '{self.title}' by {self.author}, {self.pages} pages")

class EBook(Book):
    def __init__(self, title, author, pages, filesize):
        super().__init__(title, author, pages)
        self.__filesize = filesize  # приватный атрибут с двойным подчёркиванием

    def display(self):
        print(f"Book: '{self.title}' by {self.author}, {self.pages} pages")
        print(f"File size: {self.__filesize} MB")

    def get_filesize(self):
        return self.__filesize

    def set_filesize(self, size):
        if size > 0:
            self.__filesize = size
        else:
            print("File size must be positive")

my_ebook = EBook("1984", "George Orwell", 328, 2)
my_ebook.display()
print("Current filesize:", my_ebook.get_filesize())
my_ebook.set_filesize(3)
print("Updated filesize:", my_ebook.get_filesize())
```

### Результат
![Меню](/img7/t8.png)

### Вывод:
 Реализована инкапсуляция: атрибут __filesize сделан приватным с геттером get_filesize() и сеттером set_filesize(). Это защищает данные от неправильного изменения и демонстрирует принцип сокрытия реализации.

## №10
Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def display(self):
        print(f"Book: '{self.title}' by {self.author}, {self.pages} pages")

class AudioBook(Book):
    def __init__(self, title, author, length):
        super().__init__(title, author, pages=0)  # страниц нет
        self.length = length  # длительность в минутах

    def display(self):
        print(f"Audiobook: '{self.title}' by {self.author}, length {self.length} minutes")

def show_info(book):
    book.display()

book1 = Book("1984", "George Orwell", 328)
audiobook = AudioBook("1984", "George Orwell", 660)

show_info(book1)
show_info(audiobook)

```

### Результат
![Меню](/img7/t9.png)

### Вывод:
Реализован полиморфизм: класс AudioBook переопределяет метод display(), а функция show_info() работает с любыми объектами, имеющими метод display(). Демонстрирует возможность обработки объектов разных классов единообразно через общий интерфейс.

