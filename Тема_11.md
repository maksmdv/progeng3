# Тема 11. Итераторы и генераторы.
Отчет по Теме #11 выполнил:

- Шулешов Максим Андреевич
- ИВТ-23-2

## Лабораторная работа №11
### Задание 1. Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev().

```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
    print(item)
```


### Результат.
![Меню](/img10/t1.png)

### Выводы.

1. Код использует цикл for для итерации по списку чисел от 0 до 5.
2. В каждой итерации переменная item принимает значение текущего элемента списка.
3. Каждый элемент списка выводится в консоль с помощью функции print().

### Задание 2. Класс итератор с гибкой настройкой и удобными применением.

```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1
    def __iter__(self):
        return self
    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count
if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)
```

### Результат.
![Меню](/img10/t2.png)

### Выводы

1. Этот код демонстрирует использование пользовательского класса как итератора.
2. Метод __next__() автоматически вызывается в цикле for для получения каждого следующего значения.

### Задание 3. Генератор списка.

```python
a = [i ** 2 for i in range(1,5)]

print('a -', a)
for i in a:
    print(i)
print('iter(a) -', iter(a))
for i in a:
    print(a)
```

### Результат.
![Меню](/img10/t3.png)

### Выводы

1. Итерируется по элементам списка, выводя каждый элемент отдельной строкой.


### Задание 4. Выражения генераторы.


```python
b = (i**2 for i in range(1,5))
print(b)
print('first')
for i in b:
    print(i)
print('srcond')
for i in b:
    print(i)
```
### Результат.
![Меню](/img10/t4.png)

### Выводы
1. Генератор выражения создает объект-итератор.
2. Можно использовать его многократно без повторного вычисления значений.

### Задание 5. Такой же счетчик, как и в первом задании, только это генератор и использует yield.

```python
def countdown(count):
    while count >=0:
        yield count
        count -= 1

if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print (i)
```
### Результат.
![Меню](/img10/t5.png)
### Выводы

1. countdown - это генератор-функция, использующая ключевое слово yield.
2. Генератор автоматически итерируется в цикле for.

## Самостоятельная работа №11

### Задание 1. Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.

```python
def fib(n):
    a = 1
    b = 1
    for _ in range(n):
        yield a
        a,b = b, a+b

fib200 = list(fib(200))
print(fib200[-1])
```


### Результат.
![Меню](/img10/t6.png)

### Выводы

1. Создание списка из 200 чисел Фибоначчи может быть ресурсоемким для больших значений n.
2. Последнее число в списке (6765) соответствует 199-му числу Фибоначчи (поскольку индексация начинается с 0).

### Задание 2. К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла.

```python
def fib(n):
    a = 1
    b = 1
    with open("fib.txt", "w") as file:
        for _ in range(n):
            file.write(str(a)+"\n")
            yield a
            a,b = b, a+b

fib200 = list(fib(200))
print(fib200[-1])
```
### Результат.
![Меню](/img10/t7.png)
![Меню](/img10/t8.png)


### Выводы

1. Файл fib.txt содержит числа Фибоначчи, разделенные переносами строки. Последнее число в списке fib200 равно 4181.


## Общие выводы по теме
- На основе всех представленных выше заданий можно сделать выводы о том, что итераторы и генераторы - это два способа работать со списками данных в Python. Итераторы - это объекты, которые позволяют перебирать элементы списка по одному. Генераторы - это особый тип итераторов, которые создают списки "на лету", не храня все данные одновременно в памяти. Они удобны для работы с большими объемами данных, так как экономят место и позволяют получать значения по мере необходимости.

